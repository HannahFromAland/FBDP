# 实验四 

## 实验环境准备

### 版本说明

- Ubuntu 16.04
- JDK 1.8
- Hadoop 3.3.0
- Hive  3.1.2
- Scala 2.11.6
- Spark 3.0.1

## 最热门商品和最受年轻人关注商家

### MapReduce实现

- 首先需要通过MapReduce实现用户行为日志和用户画像的`join`操作（)

- `join`操作可以在Map端实现，也可以在Reduce端实现；Map端适合两表中有一个较小表，可以先将其读入缓存，再和另一张大表进行匹配,Reduce端操作集中于Reducer，容易造成数据倾斜（但数据集里`user_info`已经4.5MB了...于是选择Reduce端操作，并将有缺失值的数据作删除处理)
- 处理后的文件预览

![image.png](https://i.loli.net/2020/12/15/ZSfQ8eYzcv1wH3D.png)

- 将join后的总表重命名为`user_all`之后上传至HDFS

```bash
$ mv part-r-00000 user_all
$ hdfs dfs -ls  /user/hann/input
```

- 统计最受欢迎的商品（最受欢迎商家的三类数据处理标准类似）

> 根据**最受欢迎**的定义：添加购物车+购买+添加收藏夹前100名
>
> 需要考虑的去重问题：
>
> - 由于购买应该是商品受欢迎程度最重要的决定因素，同一用户多次重复购买特定商品也是表明商品受欢迎程度的影响因素而非噪音，因此对购买操作仅进行计数处理（即不需要对同一用户多次操作进行去重）
> - 而添加购物车和收藏夹的动作对同一用户来说多次进行是没有任何特殊业务意义（多次操作甚至在某种程度上代表购买欲望不强因此出现多次删除又加入购物车/收藏夹的情况x），因此决定对添加购物车和添加收藏夹的用户操作进行去重处理
> - 假设同一用户的购买和添加购物车/收藏夹操作之间不产生重复影响
> - 进一步优化方向（但因为感觉略不符合题意所以没实现hh只是对于该分析逻辑的想法）：对三种行为的计数进行加权，如`单次购买行为：单次添加购物车：单次添加收藏夹=50%：30%：20%`，可以有效区分被过多添加收藏夹/购物车的商品与购买次数多的商品之间的“受欢迎程度”

- 使用两次MapReduce实现：第一次MapReduce实现去重和频率统计，第二次MapReduce进行频率倒排（源文件分别为`Product/src/main/java/PopularItem/AllItem` 以及`Product/src/main/java/PopularItem/PopMerYoung` 

- 结果见`Product/PopularItem` 及`Product/PopularMerchant`

  
